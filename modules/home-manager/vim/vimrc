" Basic Options
set autoread              " Reload files that have not been modified
set backspace=2           " Makes backspace behave like you'd expect
set colorcolumn=80        " Highlight 80 character limit
set hidden                " Allow buffers to be backgrounded without being saved
set laststatus=2          " Always show the status bar
set list                  " Show invisible characters
set listchars=tab:›\ ,eol:¬,trail:⋅ "Set the characters for the invisibles
set number
set ruler                 " Show the line number and column in the status bar
set t_Co=256              " Use 256 colors
set scrolloff=999         " Keep the cursor centered in the screen
set showmatch             " Highlight matching braces
set showmode              " Show the current mode on the open buffer
set splitbelow            " Splits show up below by default
set splitright            " Splits go to the right by default
set title                 " Set the title for gvim
syntax on                 " Enable filetype detection by syntax

" Backup settings
call mkdir($HOME . "/.vim/swap", "p")
call mkdir($HOME . "/.vim/backup", "p")
call mkdir($HOME . "/.vim/undo", "p")

execute "set directory=~/.vim/swap"
execute "set backupdir=~/.vim/backup"
execute "set undodir=~/.vim/undo"
set backup
set undofile
set writebackup

" Search settings
set hlsearch   " Highlight results
set ignorecase " Ignore casing of searches
set incsearch  " Start showing results as you type
set smartcase  " Be smart about case sensitivity when searching

" Tab settings
set expandtab     " Expand tabs to the proper type and size
set tabstop=4     " Tabs width in spaces
set softtabstop=4 " Soft tab width in spaces
set shiftwidth=4  " Amount of spaces when shifting
set autoindent 	  " Autoindent new lines

" AutoComplete options
set wildmenu
set wildmode=longest:full,full
set wop=pum

" Tabs
" nnoremap <C-t> :tabnew<CR>
" nnoremap <C-c> :tabclose<CR>
nnoremap <C-[> :tabprevious<CR>
nnoremap <C-]> :tabnext<CR>

" Force write files that requires sudo access
cmap w!! %!sudo tee > /dev/null %

" Close all buffers except the current active one
nmap <leader>ca :%bd <bar> e# <bar> bd# <CR>

" Shortcut to yanking to the system clipboard
map <leader>y "+y
map <leader>p "+p

" Get rid of search highlights
noremap <silent><leader>/ :nohlsearch<cr>

""" AutoCommands
" Clear whitespace at the end of lines automatically
autocmd BufWritePre * :%s/\s\+$//e

" make vim follow the terminal true color
" https://github.com/sonph/onehalf/tree/master/vim#true-colors
if exists('+termguicolors')
  " fix colorscheme with modern terminal
  let g:terminal_ansi_colors = [
        \'#383a42', '#e45649', '#50a14f', '#c18401', '#0184bc',
        \'#a626a4', '#0997b3', '#fafafa', '#a0a1a7', '#fafafa',
        \'#d4d4d4', '#e5e5e5', '#f0f0f0', '#f0f0f0', '#bfceff', '#f0f0f0' ]
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors
endif

colorscheme onehalfdark
" https://github.com/sonph/onehalf/pull/106/files
hi Pmenu guifg=#dcdfe4 ctermfg=188
hi Pmenu gui=NONE cterm=NONE
hi Pmenu guibg=#313640 ctermbg=237

"
" nicer Airline viewer
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1
let g:bufferline_echo = 0
let g:airline_powerline_fonts = 1

" GitGutter
" function! GitStatus()
"   let [a,m,r] = GitGutterGetHunkSummary()
"   return printf('+%d ~%d -%d', a, m, r)
" endfunction
" set statusline+=%{GitStatus()}

autocmd BufWritePost * GitGutter

" Make GitGutter use popups instead of quickfix
let g:gitgutter_preview_win_floating = 1
let g:gitgutter_floating_window_options = {
            \ 'highlight': 'Normal',
            \ 'padding': [1],
            \ 'border': [1],
            \ 'mapping': v:true,
            \ 'scrollbar': v:true,
            \ 'moved': [0, 999]
            \}

if !has('nvim')
    let g:lsp_settings = {
    \  'json-languageserver': {'cmd': ['vscode-json-languageserver', '--stdio']},
    \}
let g:lsp_log_file = expand('~/vim-lsp.log')
function! s:on_lsp_buffer_enabled() abort
    setlocal omnifunc=lsp#complete
    setlocal signcolumn=yes
    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
    nmap <buffer> gd <plug>(lsp-definition)
    nmap <buffer> gs <plug>(lsp-document-symbol-search)
    nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
    nmap <buffer> gr <plug>(lsp-references)
    nmap <buffer> gi <plug>(lsp-implementation)
    nmap <buffer> gt <plug>(lsp-type-definition)
    nmap <buffer> <leader>rn <plug>(lsp-rename)
    nmap <buffer> [g <plug>(lsp-previous-diagnostic)
    nmap <buffer> ]g <plug>(lsp-next-diagnostic)
    nmap <buffer> K <plug>(lsp-hover)
    nnoremap <buffer> <expr><c-f> lsp#scroll(+4)
    nnoremap <buffer> <expr><c-d> lsp#scroll(-4)
    let g:lsp_format_sync_timeout = 1000
    autocmd! BufWritePre *.rs,*.go,*.nix call execute('LspDocumentFormatSync')
endfunction


augroup lsp_install
    au!
    autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END


let g:OmniSharp_server_use_net6 = 1
let g:OmniSharp_log_dir = '~/.local/share'
let g:OmniSharp_server_path = '/etc/profiles/per-user/alialabbas/bin/OmniSharp' " Consider writing this with Nix to make the write subtitute instead of hardcoding it here
let g:OmniSharp_popup_options = {
    \ 'highlight': 'Normal',
    \ 'padding': [1],
    \ 'border': [1]
    \}
let g:OmniSharp_loglevel = 'info'

autocmd FileType cs nnoremap gd :OmniSharpGotoDefinition<CR>
autocmd FileType cs nnoremap gi :OmniSharpFindImplementations<CR>
autocmd FileType cs nnoremap gs :OmniSharpFindSymbol<CR>
autocmd FileType cs nnoremap gu :OmniSharpFindUsages<CR>
autocmd FileType cs nnoremap gm :OmniSharpFindMembers<CR>
autocmd FileType cs nnoremap gh :OmniSharpDocumentation<CR>
autocmd FileType cs nnoremap <S-k> :OmniSharpPreviewDefinition<CR>

" FZF mappings
nnoremap <silent> <leader>ff :GitFiles<CR>
nnoremap <silent> <leader>fg :Rg<CR>
nnoremap <silent> <leader>fb :Buffers<CR>

" AsyncComplete
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"

" Vimspector
let g:vimspector_enable_mappings = 'HUMAN'
" TODO: make this filetype plugin to setup the variables to make it easier to
" modify and extend
let g:vimspector_adapters = {
    \   'netcoredbg': {
    \     'attach': {
    \       'pidProperty': 'processId',
    \       'pidSelect': 'ask'
    \     },
    \     'command': [
    \       'netcoredbg',
    \       '--interpreter=vscode'
    \     ],
    \     'configuration': {
    \       'cwd': '${workspaceRoot}'
    \     },
    \     'name': 'netcoredbg'
    \   },
    \   'delve': {
    \     'command': ['dlv', 'dap', '--listen', '${listenOn}:${port}', '*${dlvFlags}' ],
    \      'port': '${port}',
    \      'tty': 'true',
    \      'variables': {
    \         'dlvFlags': '', 'listenOn': '127.0.0.1', 'port': '${unusedLocalPort}'
    \      }
    \   }
    \ }

let g:vimspector_configurations = {
  \   'dotnet default prompt launch': {
  \     'adapter': 'netcoredbg',
  \     'configuration': {
  \       'request': 'launch',
  \       'default': v:false,
  \       'program': '${workspaceRoot}/bin/Debug/net6.0/${DLL}',
  \       'args': [],
  \       'stopAtEntry': v:false
  \     }
  \   },
  \  'go default go.mod': {
  \    'adapter': 'delve',
  \     'filetypes': [ 'go' ],
  \    'configuration': {
  \      'request': 'launch',
  \      'program': '${fileDirname}',
  \      'mode': 'debug'
  \    }
  \  },
  \  'go default file': {
  \     'adapter': 'delve',
  \     'filetypes': [ 'go' ],
  \     'configuration': {
  \         'request': 'launch',
  \         'program': '${file}',
  \         'mode': 'debug'
  \     }
  \   },
  \  'go test go.mod': {
  \    'adapter': 'delve',
  \     'filetypes': [ 'go' ],
  \    'configuration': {
  \      'request': 'launch',
  \      'program': '${fileDirname}',
  \      'mode': 'test'
  \    }
  \  },
  \  'go test file': {
  \     'adapter': 'delve',
  \     'filetypes': [ 'go' ],
  \     'configuration': {
  \         'request': 'launch',
  \         'program': '${file}',
  \         'mode': 'test'
  \     }
  \   },
  \}


" Ideally you would read the csproj to find the assembly
" From their, we can either find the assemblby name from the xml
" Or default project name
function GetDotnetDLL() abort
    let dlls = []
    let host = OmniSharp#GetHost()
    for project in host.job.projects
        call add(dlls, project.target)
    endfor
    let choosen_target = fzf#run({'source': dlls})
    call vimspector#LaunchWithConfigurations({
                \    'launch': {
                \      'adapter': 'netcoredbg',
                \      'configuration': {
                \        'request': 'launch',
                \        'program': choosen_target[0],
                \        'args': [],
                \      }
                \    }
                \})
endfunction
let g:lsp_preview_float = 1
endif
au BufRead,BufNewFile */playbooks/*.yml set filetype=yaml.ansible

" I don't know what is setting ESC to previoustab but it is annoying, reset it
unmap <ESC>

if has('nvim')
" Not the best folding right now since some scm objects don't fold on
" comments by default, need to override those later on
set foldmethod=expr
set foldexpr=nvim_treesitter#foldexpr()
set nofoldenable                     " Disable folding at startup.

lua << EOF
-- set termguicolors to enable highlight groups
vim.opt.title = false -- Fix wsl/windows-termainl
vim.opt.termguicolors = true
vim.cmd [[autocmd BufWritePre *.go,*.nix,*.rs lua vim.lsp.buf.format()]]

require'nvim-treesitter.configs'.setup {
  highlight = {
    enable = true
  },
  playground = {
   enable = true,
   disable = {},
   updatetime = 25, -- Debounced time for highlighting nodes in the playground from source code
   persist_queries = false, -- Whether the query persists across vim sessions
   keybindings = {
     toggle_query_editor = 'o',
     toggle_hl_groups = 'i',
     toggle_injected_languages = 't',
     toggle_anonymous_nodes = 'a',
     toggle_language_display = 'I',
     focus_language = 'f',
     unfocus_language = 'F',
     update = 'R',
     goto_node = '<cr>',
     show_help = '?',
     },
  }
}

-- icons for telescope file types and such
local icons = require("nvim-nonicons")
require("telescope").setup({
  defaults = {
    prompt_prefix = "  " .. icons.get("telescope") .. "  ",
    selection_caret = " ❯ ",
    entry_prefix = "   ",
  },
})
vim.api.nvim_set_keymap("n", "<leader>tt", ":Telescope<CR>", {noremap = true, silent = true})

-- nvim-dap Mappings Standard Visual studio convetion... Can't do Shift+extra key so we are using leader instead
local defaultKeymapOptions = {noremap = true, silent = true}
vim.api.nvim_set_keymap("n", "<F5>", ":DapContinue<CR>", defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<leader><F5>", ":DapTerminate<CR>", defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<F9>", ":DapToggleBreakpoint<CR>", {noremap = true, silent = true})
vim.api.nvim_set_keymap("n", "<leader><F9>", [[ <Esc><Cmd>lua require('dap').clear_breakpoints()<CR>]], {noremap = true, silent = true})
vim.api.nvim_set_keymap("n", "<F10>", ":DapStepOver<CR>", defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<leader><F11>", ":DapStepOut<CR>", defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<F11>", ":DapStepInto<CR>", defaultKeymapOptions)

-- neotest Mappings t for test then the action
-- I dislike how lua plugins don't expose commands that do the same thing, these should also have an easy command istead of these massives lists
vim.api.nvim_set_keymap("n", "<leader>tr", [[ <Esc><Cmd>lua require('neotest').run.run()<CR> ]], defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<leader>tf", [[ <Esc><Cmd>lua require('neotest').run.run(vim.fn.expand("%"))<CR> ]], defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<leader>td", [[ <Esc><Cmd>lua require("neotest").run.run({strategy = "dap"})<CR> ]], defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<leader>ts", [[ <Esc><Cmd>lua require("neotest").summary.toggle()<CR> ]], defaultKeymapOptions)
vim.api.nvim_set_keymap("n", "<leader>to", [[ <Esc><Cmd>lua require("neotest").output_panel.toggle()<CR> ]], defaultKeymapOptions)

require('Comment').setup()
require('refactoring').setup({})
-- Remaps for the refactoring operations currently offered by the plugin
-- These maps are convoluted and I prefer commands over a huge set of shortcut
vim.api.nvim_set_keymap("v", "<leader>re", [[ <Esc><Cmd>lua require('refactoring').refactor('Extract Function')<CR>]], {noremap = true, silent = true, expr = false})
vim.api.nvim_set_keymap("v", "<leader>rf", [[ <Esc><Cmd>lua require('refactoring').refactor('Extract Function To File')<CR>]], {noremap = true, silent = true, expr = false})
vim.api.nvim_set_keymap("v", "<leader>rv", [[ <Esc><Cmd>lua require('refactoring').refactor('Extract Variable')<CR>]], {noremap = true, silent = true, expr = false})
vim.api.nvim_set_keymap("v", "<leader>ri", [[ <Esc><Cmd>lua require('refactoring').refactor('Inline Variable')<CR>]], {noremap = true, silent = true, expr = false})

-- Extract block doesn't need visual mode
vim.api.nvim_set_keymap("n", "<leader>rb", [[ <Cmd>lua require('refactoring').refactor('Extract Block')<CR>]], {noremap = true, silent = true, expr = false})
vim.api.nvim_set_keymap("n", "<leader>rbf", [[ <Cmd>lua require('refactoring').refactor('Extract Block To File')<CR>]], {noremap = true, silent = true, expr = false})

-- Inline variable can also pick up the identifier currently under the cursor without visual mode
vim.api.nvim_set_keymap("n", "<leader>ri", [[ <Cmd>lua require('refactoring').refactor('Inline Variable')<CR>]], {noremap = true, silent = true, expr = false})


-- Mappings.
-- See `:help vim.diagnostic.*` for documentation on any of the below functions
local opts = { noremap=true, silent=true }
vim.keymap.set('n', '<space>e', vim.diagnostic.open_float, opts)
vim.keymap.set('n', '[d', vim.diagnostic.goto_prev, opts)
vim.keymap.set('n', ']d', vim.diagnostic.goto_next, opts)
vim.keymap.set('n', '<space>q', vim.diagnostic.setloclist, opts)

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  -- Enable completion triggered by <c-x><c-o>
  vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  -- See `:help vim.lsp.*` for documentation on any of the below functions
  local bufopts = { noremap=true, silent=true, buffer=bufnr }
  vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, bufopts)
  vim.keymap.set('n', 'gd', vim.lsp.buf.definition, bufopts)
  vim.keymap.set('n', 'K', vim.lsp.buf.hover, bufopts)
  vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, bufopts)
  vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help, bufopts)
  vim.keymap.set('n', '<space>wa', vim.lsp.buf.add_workspace_folder, bufopts)
  vim.keymap.set('n', '<space>wr', vim.lsp.buf.remove_workspace_folder, bufopts)
  vim.keymap.set('n', '<space>wl', function()
    print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
  end, bufopts)
  vim.keymap.set('n', '<space>D', vim.lsp.buf.type_definition, bufopts)
  vim.keymap.set('n', '<space>rn', vim.lsp.buf.rename, bufopts)
  vim.keymap.set('n', '<space>ca', vim.lsp.buf.code_action, bufopts)
  vim.keymap.set('n', 'gr', vim.lsp.buf.references, bufopts)
  vim.keymap.set('n', '<space>f', function() vim.lsp.buf.format { async = true } end, bufopts)
end

local cmp = require"cmp"
cmp.setup {
    snippet = {
        expand = function(args)
          vim.fn["vsnip#anonymous"](args.body)
        end,
      },
    mapping = cmp.mapping.preset.insert({
      ['<C-Space>'] = cmp.mapping.complete({ select = true }),
      ['<C-e>'] = cmp.mapping.close(),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<Tab>'] = cmp.mapping(cmp.mapping.select_next_item(), { 'i', 's' }),
      ['<S-Tab>'] = cmp.mapping(cmp.mapping.select_prev_item(), { 'i', 's' }),
      ['<CR>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
    }),
  sources = {
      { name = 'nvim_lsp' },
      { name = 'vsnip' },
      { name = 'path' },
      { name = 'nvim_lua' },
      { name = 'git' },
      { name = 'conventionalcommits' },
      { name = 'buffer' },
      { name = 'dap' }
  }
}

require("cmp_git").setup()
-- require'cmp'.setup.buffer {
--   sources = require'cmp'.config.sources(
--     {{ name = 'conventionalcommits' }},
--     {{ name = 'buffer' }}
--   ),
-- }

-- The nvim-cmp almost supports LSP's capabilities so You should advertise it to LSP servers..
local capabilities = require('cmp_nvim_lsp').default_capabilities()

local lsp_flags = {
  -- This is the default in Nvim 0.7+
  debounce_text_changes = 150,
}
local pid = vim.fn.getpid()
-- On linux/darwin if using a release build, otherwise under scripts/OmniSharp(.Core)(.cmd)
local omnisharp_bin = "OmniSharp"
-- on Windows
-- local omnisharp_bin = "/path/to/omnisharp/OmniSharp.exe"

local config = {
  handlers = {
    ["textDocument/definition"] = require('omnisharp_extended').handler,
  },
  cmd = { omnisharp_bin, '--languageserver' , '--hostPID', tostring(pid) },
  -- rest of your settings
  on_attach = on_attach,
  capabilities = capabilities,
}

require'lspconfig'.omnisharp.setup(config)

-- TODO: probably need a server and a config... Maybe better make the config a common thing in a common plugin and then just add the config you need per file type
require'lspconfig'.sumneko_lua.setup {
  settings = {
    Lua = {
      runtime = {
        -- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
        version = 'LuaJIT',
      },
      diagnostics = {
        -- Get the language server to recognize the `vim` global
        globals = {'vim'},
      },
      workspace = {
        -- Make the server aware of Neovim runtime files
        library = vim.api.nvim_get_runtime_file("", true),
      },
      -- Do not send telemetry data containing a randomized but unique identifier
      telemetry = {
        enable = false,
      },
    },
  },
}

-- Omnisharp is not in this list because it needs special handling
local caps = vim.tbl_extend(
      'keep',
      vim.lsp.protocol.make_client_capabilities(),
      require('cmp_nvim_lsp').default_capabilities()
    );
require('lspconfig').nil_ls.setup {
    on_attach = on_attach,
    capabilities = capabilities,
    settings = {
        ['nil'] = {
            formatting = {
                command = { "nixpkgs-fmt" },
            },
        },
    },
}

local servers = { "gopls", "ansiblels"}
for _, lsp in ipairs(servers) do
    require('lspconfig')[lsp].setup {
        on_attach = on_attach,
        capabilities = capabilities,
    }
end
-- dap configurations
local dap, dapui = require("dap"), require("dapui")
vim.api.nvim_set_hl(0, 'DapBreakpoint', { ctermbg = 0, fg = '#993939' })
vim.api.nvim_set_hl(0, 'DapLogPoint', { ctermbg = 0, fg = '#61afef' })
vim.api.nvim_set_hl(0, 'DapStopped', { ctermbg = 0, fg = '#98c379' })

vim.fn.sign_define('DapBreakpoint', { text='', texthl='DapBreakpoint', linehl='', numhl='' })
vim.fn.sign_define('DapBreakpointCondition', { text='ﳁ', texthl='DapBreakpoint', linehl='', numhl='' })
vim.fn.sign_define('DapBreakpointRejected', { text='', texthl='DapBreakpoint', linehl='', numhl= '' })
vim.fn.sign_define('DapLogPoint', { text='', texthl='DapLogPoint', linehl='', numhl= '' })
vim.fn.sign_define('DapStopped', { text='', texthl='DapStopped', linehl='', numhl= '' })

dapui.setup()


dap.listeners.after.event_initialized["dapui_config"] = function()
  dapui.open()
end
dap.listeners.before.event_terminated["dapui_config"] = function()
  dapui.close()
end
dap.listeners.before.event_exited["dapui_config"] = function()
  dapui.close()
end

vim.g.dotnet_build_project = function()
    local default_path = vim.fn.getcwd() .. '/'
    if vim.g['dotnet_last_proj_path'] ~= nil then
        default_path = vim.g['dotnet_last_proj_path']
    end
    local path = vim.fn.input('Path to your *proj file', default_path, 'file')
    vim.g['dotnet_last_proj_path'] = path
    local cmd = 'dotnet build -c Debug ' .. path .. ' > /dev/null'
    print('')
    print('Cmd to execute: ' .. cmd)
    local f = os.execute(cmd)
    if f == 0 then
        print('\nBuild: ✔️ ')
    else
        print('\nBuild: ❌ (code: ' .. f .. ')')
    end
end

vim.g.dotnet_get_dll_path = function()
    local request = function()
        return vim.fn.input('Path to dll', vim.fn.getcwd() .. '/bin/Debug/net6.0', 'file')
    end

    if vim.g['dotnet_last_dll_path'] == nil then
        vim.g['dotnet_last_dll_path'] = request()
    else
        if vim.fn.confirm('Do you want to change the path to dll?\n' .. vim.g['dotnet_last_dll_path'], '&yes\n&no', 2) == 1 then
            vim.g['dotnet_last_dll_path'] = request()
        end
    end

    return vim.g['dotnet_last_dll_path']
end

-- Do I need to return this string to a array
vim.g.get_dap_args = function ()
    local getUserArgs = function()
        return vim.fn.input('argments to be passed to your application')
    end

    if vim.g['dap_args'] == nil then
        vim.g['dap_args'] = getUserArgs()
    else
        if vim.fn.confirm('Do you want to use the same args' .. vim.g['dap_args'], '&yes\n&no', 2) == 1 then
            vim.g['dap_args'] = getUserArgs()
        end
    end

    return vim.g['dap_args']
end

local config = {
  {
    type = "netcoredbg",
    name = "launch - netcoredbg",
    request = "launch",
    program = function()
        if vim.fn.confirm('Should I recompile first?', '&yes\n&no', 2) == 1 then
            vim.g.dotnet_build_project()
        end
        return vim.g.dotnet_get_dll_path()
    end,
    args = function() return vim.split(vim.g.get_dap_args(), ' ') end
  },
}


dap.adapters.netcoredbg = {
  type = 'executable',
  command = 'netcoredbg',
  args = {'--interpreter=vscode'}
}

dap.configurations.cs = config
dap.configurations.fsharp = config

-- Go dap adapter and configurations -- TODO: could add attach request and other ones
dap.adapters.go = {
    type = 'server',
    port = '${port}',
    executable = {
        command = 'dlv',
        args = { 'dap', '-l', '127.0.0.1:${port}'},
    },
}

dap.configurations.go = {
    {
       type = "go",
       name = "debug go.mod",
       request = "launch",
       program = "${fileDirname}",
       args = function() return vim.split(vim.g.get_dap_args(), ' ') end
    },
    {
       type = "go",
       name = "Debug file",
       request = "launch",
       program = "${file}",
       args = function() return vim.split(vim.g.get_dap_args(), ' ') end
    },
    {
       type = "go",
       name = "Debug test file",
       request = "launch",
       program = "${file}",
       mode = "test",
    },
    {
        type = "go",
        name = "Debug test go.mod",
        request = "launch",
        program = "${fileDirname}",
        mode = "test",
    }
}


require("neotest").setup({
  adapters = {
    require("neotest-dotnet"),
    require("neotest-go")({
      experimental = {
        test_table = true,
      },
      args = { "-count=1", "-timeout=60s" }
    })
  }
})



local sidebar = require("sidebar-nvim")
sidebar.setup({
open = true,
sections = { 'datetime', 'git', 'diagnostics', 'todos', 'symbols', 'buffers', 'files', 'containers'},
todos = {
        icon = "",
        ignored_paths = {'~'}, -- ignore certain paths, this will prevent huge folders like $HOME to hog Neovim with TODO searching
        initially_closed = false, -- whether the groups should be initially closed on start. You can manually open/close groups later.
    },
files = {
        icon = "",
        show_hidden = false,
        ignored_paths = {"%.git$", "bin", "obj", "~"}
    },

})

vim.keymap.set("n", "<S-B>", function() if sidebar.is_open() then sidebar.toggle() else sidebar.focus() end end)

require('neogen').setup {
    languages = {
        cs = {
            template = {
                annotation_convention = "xmldoc"
            },
        },
    },
}

local Terminal = require("toggleterm.terminal").Terminal
require('toggleterm').setup{
    shade_terminals = false,
}

local nixrepl = Terminal:new({
    cmd = "nix repl",
    on_open = function(term)
        vim.cmd("startinsert!")
        vim.api.nvim_buf_set_keymap(term.bufnr, "n", "q", "<cmd>close<CR>", opts)
    end,
    on_close = function(term)
        vim.cmd("startinsert!")
    end,
})

vim.api.nvim_create_user_command('NixRepl', function() nixrepl:toggle() end, { nargs = 0 })

-- Terminal keymaps
vim.keymap.set('t', '<esc>', [[<C-\><C-n>]], opts) -- sane people mapping to go out of focus
vim.keymap.set('n', '<C-T>', ':ToggleTerm<CR>', opts)

-- TODO: Snippet with cmp-nvim is a bit sketchy but this will suffice for now
local cfg = require("yaml-companion").setup({
    lspconfig = {
        on_attach = on_attach,
        capabilities = capabilities,
    },
})
require("telescope").load_extension("yaml_schema")
require("lspconfig")["yamlls"].setup(cfg)
-- TODO: move airline to vim only
require('lualine').setup({
    options = {
        disabled_filetypes = {
            statusline = { 'SidebarNvim' }
        },
    },
})
EOF
endif
